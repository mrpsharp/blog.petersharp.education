{
  
    
        "post0": {
            "title": "Q22 from the 2012 PAT paper",
            "content": ". Tip: Click &quot;Launch Binder&quot; above to open a functioning version of the notebook in binder or &quot;View in Github&quot; to download to your own machine. Note the binder instance may take some time to load. . Question . The first stage is to recreate the force function in Python . def force(x): if (x&gt;0): f = -10 else: f = -x-10 # equation of graph for x&lt;0 return f . x = np.arange(-30,20,0.1) f = [] for val in x: f.append(force(val)) fig, ax = plt.subplots() ax.plot(x,f) ax.set_xlabel(&quot;x/m&quot;) ax.set_ylabel(&quot;F/N&quot;) ax.set_title(&quot;Force function&quot;) ax.spines[&#39;left&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) fig.tight_layout() . . This is an interesting problem which demonstrates motion with a non-linear force-function. To visualise this motion python can be used to solve the differential equations for the motion using scipy.integrate.solve_ivp: . $$ frac{dx}{dt} = v frac{dv}{dt} = - frac{F}{m} $$ initialP = [10,0] # [x,v] mass = 1 def ivf(t, P): dxdt = P[1] # dx/dt = v dvdt = force(P[0]) / mass # dv/dt = F/m return [dxdt, dvdt] t_max = 10 t_range = np.arange(0,t_max,0.05) sol = solve_ivp(ivf, [0,t_max], initialP, t_eval=t_range) # sol.t, sol.y[0] = x, sol.y[1] = v from matplotlib import animation fig2, ax2 = plt.subplots() ax2.plot(x,f) ax2.set_xlabel(&quot;x/m&quot;) ax2.set_ylabel(&quot;F/N&quot;) ax2.set_title(&quot;Force function&quot;) ax2.spines[&#39;left&#39;].set_position(&#39;zero&#39;) ax2.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax2.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax2.spines[&#39;top&#39;].set_color(&#39;none&#39;) fig.tight_layout() pt, = ax2.plot([],[],color=&#39;r&#39;,marker=&quot;o&quot;, markersize=20) def update_point(t): pt.set_data(sol.y[0][t],0) return pt, ani=animation.FuncAnimation(fig2, update_point, len(t_range), interval=10, blit=True, repeat=False) . . a1 What is its speed at x=0? . This can be solved analytically: $$ text{Kinetic Energy} = text{Work done} frac{1}{2}mv^2 = Fs $$ to give $v=10 sqrt{2}=14.1 text{ ms}^{-1} . It can also be verified from the phase plot . fig3, ax3 = plt.subplots() ax3.set_xlabel(&quot;x/m&quot;) ax3.set_ylabel(&quot;v/ms^-1&quot;) ax3.set_title(&quot;Phase portrait&quot;) ax3.plot(sol.y[0],sol.y[1]) ax3.grid() fig.tight_layout() . . a2 Sketch its kinetic energy as a function of x. . Now we have the solution this is easily done. . KE = 0.5*mass*sol.y[1]**2 fig4, ax4 = plt.subplots() ax4.set_xlabel(&quot;x/m&quot;) ax4.set_ylabel(&quot;KE/J&quot;) ax4.plot(sol.y[0],KE) ax4.grid() fig4.tight_layout() . . a3 Sketch its velocity as well as its acceleration as a function of time t. . forces = [force(x)/mass for x in sol.y[0]] fig5, ax5 = plt.subplots(2,sharex=True) ax5[1].set_xlabel(&quot;t/s&quot;) ax5[0].set_ylabel(&quot;v / m/s&quot;) ax5[0].plot(sol.t,sol.y[1]) ax5[1].set_ylabel(&quot;a / m/s2&quot;) ax5[1].plot(sol.t,forces) ax4.grid() fig4.tight_layout() . . Now consider a case when, in addition, a friction force of a magnitude of 1 N is present for x &#8805; 0. . b1 Sketch how the velocity depends on x in that case. . This requires a new force function including a velocity dependance. . def force2(x,v): if (x&gt;0): f = -10 - np.sign(v) else: f = -x-10 return f . initialP = [10,0] # [x,v] mass = 1 def ivf2(t, P): dxdt = P[1] # dx/dt = v dvdt = (force2(P[0],P[1]) / mass) # dv/dt = F/m -v/abs(v) return [dxdt, dvdt] t_max = 180 t_range = np.arange(0,t_max,0.1) sol2 = solve_ivp(ivf2, [0,t_max], initialP,t_eval=t_range) # sol.t, sol.y[0] = x, sol.y[1] = v from matplotlib import animation fig6, ax6 = plt.subplots() ax6.plot(x,f) ax6.set_xlabel(&quot;x/m&quot;) ax6.set_ylabel(&quot;F/N&quot;) ax6.set_title(&quot;Force function&quot;) ax6.spines[&#39;left&#39;].set_position(&#39;zero&#39;) ax6.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax6.spines[&#39;bottom&#39;].set_position(&#39;zero&#39;) ax6.spines[&#39;top&#39;].set_color(&#39;none&#39;) fig6.tight_layout() pt, = ax6.plot([],[],color=&#39;r&#39;,marker=&quot;o&quot;, markersize=20) def update_point2(t): pt.set_data(sol2.y[0][t],0) return pt, ani2=animation.FuncAnimation(fig6, update_point2, len(t_range), interval=10, blit=True, repeat=False) . . The phase plot allows this to be viewed, settling into SHM around $x=-10$. . fig7, ax7 = plt.subplots() ax7.set_xlabel(&quot;x/m&quot;) ax7.set_ylabel(&quot;v/ms^-1&quot;) ax7.set_title(&quot;Phase portrait&quot;) ax7.plot(sol2.y[0],sol2.y[1]) ax7.grid() fig.tight_layout() . . b2 How many meters this point like object travelled during the time when its position coordinate x was &#8805; 0? . This requires the realisation that the force when $x&gt;0$ now depends on direction: $$ F_ text{left} = -9 text{ N}, F_ text{right} = -11 text{ N}$$ . Therefore: $$ frac{1}{2}mv_0^2 = 9x_0 frac{1}{2}mv_0^2 = 11x_1 =&gt; x_1 = frac{9}{11}x_0 frac{1}{2}mv_1^2 = 9x_1 frac{1}{2}mv_1^2 = 11x_2 =&gt; x_2 = frac{9}{11}x_1 = left( frac{9}{11} right)^2x_0 $$ . This is the start of a geometric series: $$x_ text{total}= x_0 + 2 left( frac{9}{11} right)x_0 + 2 left( frac{9}{11} right)^2x_0 + ldots = sum_{n=0}^{ infty} 2x_0 left( frac{9}{11} right)^n - x_0 = frac{20}{1- frac{9}{11}} - 10 = 100 text{ m} $$ .",
            "url": "https://blog.petersharp.education/2022/09/30/pat-2012-q22/",
            "relUrl": "/2022/09/30/pat-2012-q22/",
            "date": " • Sep 30, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Benford's Law",
            "content": ". Tip: Click &quot;Launch Binder&quot; above to open a functioning version of the notebook in binder or &quot;View in Github&quot; to download to your own machine. Note the binder instance may take some time to load. . Someone recently mentioned to me that in physics many examples of numerical data have a high likelihood that the intial digit is small. This is known as Benford&#39;s Law. The explanation isn&#39;t clear, but it does require numbers to have a wide spread in magnitudes. Even then this article makes it clear that any simple arguments are suspect. . This feels like something worth exploring! . Benford&#39;s Law gives the probabilities of the leading digit $d$ as $$ P(d) = log_{10}(d+1) - log_{10}(d) $$ . benford = np.zeros(10) benford[0] = np.nan for d in range(1,10): benford[d] = np.log10(1+1/d) print(&quot;Leading Digit Probability&quot;) for d in range(1,10): print(f&quot;{d:^14}{benford[d]:^14.2%}&quot;) . . Leading Digit Probability 1 30.10% 2 17.61% 3 12.49% 4 9.69% 5 7.92% 6 6.69% 7 5.80% 8 5.12% 9 4.58% . This is a simple function to create a list of leading digits from a list of numbers . def find_leads(vals): leads = [] for val in vals: while (val &gt;= 10): val = val // 10 leads.append(int(val)) return leads . The first trial will generate a uniform distribution of numbers between 100 and 10,000. They will then randomly evolve by multiplying by a random value between 0.9 and 1.1 and the distribution of first digits monitored. . vals = [np.random.uniform(100,10000,1000)] # calculate the changes variation = &quot;geometric&quot; for x in range(0,400): new_vals = [] for val in vals[-1]: new_vals.append(val*np.random.uniform(0.9,1.1)) vals.append(new_vals) # Calculate the leading digits all_leads = [] for t in range(0,len(vals)): leads = find_leads(vals[t]) data = Counter(leads) # data[&#39;t&#39;] = t all_leads.append(data) . Plotting the evolution... . import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython import display . . fig, ax = plt.subplots(figsize=(4, 2.5), dpi=144) def animate(i): ax.clear() # bar.set_data(all_leads[i].keys(), all_leads[i].values()) ax.bar(all_leads[i].keys(), all_leads[i].values()) ax.plot(np.arange(1,10,1),1000*benford[1:], linestyle=&quot;&quot;, marker=&quot;d&quot;,color=&#39;r&#39;, label=&quot;Benford Probability&quot;) ax.set_title(&quot;Iterations: &quot; + str(i)) ax.set_xticks(np.arange(1,10)) ax.set_ylim(0,330) ax.legend() anim = animation.FuncAnimation(fig, animate, interval=10,frames=400) plt.show() # writervideo = animation.FFMpegWriter(fps=40) # anim.save(&#39;benford2.mp4&#39;, writer=writervideo) # plt.close() . This shows a fairly rapid progression to Benfold&#39;s law - it works! . Next trial involves an arithmetic modification: adding a number between -20 and 20 each time the process cycles. . # Initial values randomly distributed vals2 = [np.random.uniform(100,10000,1000)] # calculate the changes variation = &quot;geometric&quot; for x in range(0,400): global vals2 new_vals = [] for val in vals2[-1]: change = np.random.uniform(-20,20) new_vals.append(abs(val+change)) vals2.append(new_vals) # Calculate the leading digits all_leads = [] for t in range(0,len(vals2)): leads = find_leads(vals2[t]) data = Counter(leads) # data[&#39;t&#39;] = t all_leads.append(data) fig, ax = plt.subplots(figsize=(4, 2.5), dpi=144) def animate(i): ax.clear() # bar.set_data(all_leads[i].keys(), all_leads[i].values()) ax.bar(all_leads[i].keys(), all_leads[i].values()) ax.plot(np.arange(1,10,1),1000*benford[1:], linestyle=&quot;&quot;, marker=&quot;d&quot;,color=&#39;r&#39;, label=&quot;Benford Probability&quot;) ax.set_title(&quot;Iterations: &quot; + str(i)) ax.set_xticks(np.arange(1,10)) ax.set_ylim(0,330) ax.legend() anim = animation.FuncAnimation(fig, animate, interval=10,frames=400) plt.show() # writervideo = animation.FFMpegWriter(fps=40) # anim.save(&#39;benford2.mp4&#39;, writer=writervideo) # plt.close() . . This shows no particular evolution to Benfold. We can compare the distribution of the numbers at the end of 400 iterations. . fig, axs = plt.subplots(1, 2, tight_layout=True) axs[0].hist(vals[400], 20) axs[0].set_title(&quot;Geometric variation&quot;) axs[1].hist(vals2[400], 20) axs[1].set_title(&quot;Arithmetic variation&quot;) plt.show() . . The respective maximum values are: . max1 = max(vals[400]) max2 = max(vals2[400]) print(f&quot;{max1:.3} and {max2:.3}&quot;) . 1.06e+05 and 1.04e+04 . It may make more sense to look at the histograms on a log scale. . fig, axs = plt.subplots(1, 2, tight_layout=True) logbins = np.logspace(np.log10(min(vals[400])),np.log10(max(vals[400])),20) logbins2 = np.logspace(np.log10(min(vals2[400])),np.log10(max(vals2[400])),20) axs[0].hist(vals[400], bins=logbins) axs[0].set_title(&quot;Geometric variation&quot;) axs[0].set_xscale(&#39;log&#39;) axs[1].hist(vals2[400], bins=logbins2) axs[1].set_title(&quot;Arithmetic variation&quot;) axs[1].set_xscale(&#39;log&#39;) plt.show() . It is clear that the geometric variation gives much even more spread on a log scale. This provides a good visual explanation for Benfold&#39;s Law: picking a random point on that log scale and you are most likely to land in and interval beginning with 1 (the wide intervals just after each $10^x$ label on the axis. The arithmetic variation curve only really spans one order of magnitude so this effect is much less pronounced. Running the process longer and increasing each step-size for the arithmetic variation may help. . from fastprogress.fastprogress import progress_bar # Initial values randomly distributed vals3 = np.random.uniform(100,10000,1000) # calculate the changes n = 50000 # number of iterations - change this to explore for x in progress_bar(range(0,n)): global vals3 new_vals = [] for val in vals3: change = np.random.uniform(-150,150) new_vals.append(abs(val+change)) vals3=new_vals # Calculate the leading digits leads = find_leads(vals3) all_leads = Counter(leads) fig, ax = plt.subplots(1,2, tight_layout=True) ax[0].bar(all_leads.keys(), all_leads.values()) ax[0].plot(np.arange(1,10,1),1000*benford[1:], linestyle=&quot;&quot;, marker=&quot;d&quot;,color=&#39;r&#39;, label=&quot;Benford Probability&quot;) ax[0].set_title(f&quot;Iterations: {n:,}&quot;) ax[0].set_xticks(np.arange(1,10)) ax[0].legend() logbins3 = np.logspace(np.log10(min(vals3)),np.log10(max(vals3)),20) ax[1].hist(vals3, bins=logbins3) ax[1].set_title(&quot;Arithmetic variation&quot;) ax[1].set_xscale(&#39;log&#39;) plt.show() . . . 100.00% [50000/50000 02:04&lt;00:00] It looks like it&#39;s heading in the right direction now that it spans two orders of magnitude, but it isn&#39;t completely convincing... . Another option is simply to investigate some distributions directly looking at the same two charts. . def benfold_distrb(vals, distname): # Calculate the leading digits leads = find_leads(vals) all_leads = Counter(leads) fig, ax = plt.subplots(1,2, tight_layout=True) ax[0].bar(all_leads.keys(), all_leads.values()) ax[0].plot(np.arange(1,10,1),1000*benford[1:], linestyle=&quot;&quot;, marker=&quot;d&quot;,color=&#39;r&#39;, label=&quot;Benford Probability&quot;) ax[0].set_title(distname) ax[0].set_xticks(np.arange(1,10)) ax[0].legend() logbins = np.logspace(np.log10(min(vals)),np.log10(max(vals)),20) ax[1].hist(vals, bins=20) # ax[1].set_xscale(&#39;log&#39;) plt.show() . . normal = np.random.default_rng().normal(1e7, 2.5e6, 1000) benfold_distrb(normal, &quot;Normal&quot;) . Well, that&#39;s weird. Something to do with the sampling method maybe?? Any ideas in the comments! .",
            "url": "https://blog.petersharp.education/2022/08/27/benfords-law/",
            "relUrl": "/2022/08/27/benfords-law/",
            "date": " • Aug 27, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://blog.petersharp.education/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://blog.petersharp.education/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}