{
  
    
        "post0": {
            "title": "Benford's Law",
            "content": "Someone recently mentioned to me that in physics many examples of numerical data have a high likelihood that the intial digit is small. This is known as Benford&#39;s Law. The explanation isn&#39;t clear, but it does require numbers to have a wide spread in magnitudes. Even then this article makes it clear that any simple arguments are suspect. . This feels like something worth exploring! . Benford&#39;s Law gives the probabilities of the leading digit $d$ as $$ P(d) = log_{10}(d+1) - log_{10}(d) $$ . benford = np.zeros(10) benford[0] = np.nan for d in range(1,10): benford[d] = np.log10(1+1/d) print(&quot;Leading Digit Probability&quot;) for d in range(1,10): print(f&quot;{d:^14}{benford[d]:^14.2%}&quot;) . . Leading Digit Probability 1 30.10% 2 17.61% 3 12.49% 4 9.69% 5 7.92% 6 6.69% 7 5.80% 8 5.12% 9 4.58% . This is a simple function to create a list of leading digits from a list of numbers . def find_leads(vals): leads = [] for val in vals: while (val &gt;= 10): val = val // 10 leads.append(int(val)) return leads . The first trial will generate a uniform distribution of numbers between 100 and 10,000. They will then randomly evolve by multiplying by a random value between 0.9 and 1.1 and the distribution of first digits monitored. . vals = [np.random.uniform(100,10000,1000)] # calculate the changes variation = &quot;geometric&quot; for x in range(0,400): global vals new_vals = [] for val in vals[-1]: new_vals.append(val*np.random.uniform(0.9,1.1)) vals.append(new_vals) # Calculate the leading digits all_leads = [] for t in range(0,len(vals)): leads = find_leads(vals[t]) data = Counter(leads) # data[&#39;t&#39;] = t all_leads.append(data) . Plotting the evolution... . import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython import display . . fig, ax = plt.subplots(figsize=(4, 2.5), dpi=144) def animate(i): ax.clear() # bar.set_data(all_leads[i].keys(), all_leads[i].values()) ax.bar(all_leads[i].keys(), all_leads[i].values()) ax.plot(np.arange(1,10,1),1000*benford[1:], linestyle=&quot;&quot;, marker=&quot;d&quot;,color=&#39;r&#39;, label=&quot;Benford Probability&quot;) ax.set_title(&quot;Iterations: &quot; + str(i)) ax.set_xticks(np.arange(1,10)) ax.set_ylim(0,330) ax.legend() anim = animation.FuncAnimation(fig, animate, interval=10,frames=400) plt.show() # writervideo = animation.FFMpegWriter(fps=40) # anim.save(&#39;benford2.mp4&#39;, writer=writervideo) # plt.close() . This shows a fairly rapid progression to Benfold&#39;s law - it works! . Next trial involves an arithmetic modification: adding a number between -20 and 20 each time the process cycles. . # Initial values randomly distributed vals2 = [np.random.uniform(100,10000,1000)] # calculate the changes variation = &quot;geometric&quot; for x in range(0,400): global vals2 new_vals = [] for val in vals2[-1]: change = np.random.uniform(-20,20) if val+change &gt; 10: new_vals.append(val+change) else: new_vals.append(val-change) vals2.append(new_vals) # Calculate the leading digits all_leads = [] for t in range(0,len(vals2)): leads = find_leads(vals2[t]) data = Counter(leads) # data[&#39;t&#39;] = t all_leads.append(data) fig, ax = plt.subplots(figsize=(4, 2.5), dpi=144) def animate(i): ax.clear() # bar.set_data(all_leads[i].keys(), all_leads[i].values()) ax.bar(all_leads[i].keys(), all_leads[i].values()) ax.plot(np.arange(1,10,1),1000*benford[1:], linestyle=&quot;&quot;, marker=&quot;d&quot;,color=&#39;r&#39;, label=&quot;Benford Probability&quot;) ax.set_title(&quot;Iterations: &quot; + str(i)) ax.set_xticks(np.arange(1,10)) ax.set_ylim(0,330) ax.legend() anim = animation.FuncAnimation(fig, animate, interval=10,frames=400) plt.show() # writervideo = animation.FFMpegWriter(fps=40) # anim.save(&#39;benford2.mp4&#39;, writer=writervideo) # plt.close() . . This shows no particular evolution to Benfold. We can compare the distribution of the numbers at the end of 400 iterations. . fig, axs = plt.subplots(1, 2, sharey=True, tight_layout=True) axs[0].hist(vals[400], 20) axs[1].hist(vals2[400], 20) plt.show() . . The respective maximum values are: . max1 = max(vals[400]) max2 = max(vals2[400]) print(f&quot;{max1:.3} and {max2:.3}&quot;) . 1.14e+05 and 1.02e+04 . It may be that running the process for much longer helps....next steps. . from fastprogress.fastprogress import progress_bar # Initial values randomly distributed vals3 = np.random.uniform(100,10000,1000) # calculate the changes n = 100000 for x in progress_bar(range(0,n)): global vals3 new_vals = [] for val in vals3: change = np.random.uniform(-20,20) if (val+change) &gt; 10: new_vals.append(val+change) else: new_vals.append(val-change) vals3=new_vals # Calculate the leading digits leads = find_leads(vals3) all_leads = Counter(leads) fig, ax = plt.subplots(figsize=(4, 2.5), dpi=144) ax.bar(all_leads.keys(), all_leads.values()) ax.plot(np.arange(1,10,1),1000*benford[1:], linestyle=&quot;&quot;, marker=&quot;d&quot;,color=&#39;r&#39;, label=&quot;Benford Probability&quot;) ax.set_title(&quot;Iterations: &quot; + str(n)) ax.set_xticks(np.arange(1,10)) ax.set_ylim(0,330) ax.legend() plt.show() . . . 100.00% [100000/100000 04:06&lt;00:00] Moving in the right direction! Feel free to let it run... .",
            "url": "https://blog.petersharp.education/jupyter/mathematics/2022/08/26/benfords-law.html",
            "relUrl": "/jupyter/mathematics/2022/08/26/benfords-law.html",
            "date": " • Aug 26, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://blog.petersharp.education/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://blog.petersharp.education/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}